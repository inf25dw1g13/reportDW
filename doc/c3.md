# C3 : Produto

Descrição do desenvolvimento do produto, a sua instalação e execução.

## 3.1 Desenvolvimento

**3.1.1 Visão Geral do Projeto**

- **DB-master:**  
Servidor principal responsável pelas operações de escrita.

- **DB-réplicas:**  
Servidores secundários configurados como réplicas, para operações de leitura.

- **MaxScale:**  
Proxy e roteador que implementa o read/write splitting, e encaminha automaticamente os pedidos de escrita e leitura para as respetivas bases de dados.

- **API:**  
Serviço Node.js/Express que implementa os endpoints da API e comunica com a base de dados exclusivamente através do MaxScale.


**3.1.2 Arquitetura do Projeto:**

![Arquitetura_Food_API](/doc/images/arquitetura_api.png)
- Imagem desenhada no Miro: [Arquitetura em Miro](https://miro.com/app/board/uXjVJhjT7X0=/?share_link_id=289133236006)


**3.1.3 Fluxo de Dados:**

![Fluxo de Dados](/doc/images/fluxo_dados.jpg)
- Imagem desenhada no Miro: [Fluxo de Dados em Miro](https://miro.com/app/board/uXjVJi6sH_8=/?share_link_id=315844749630)


**3.1.4 Estrutura do Projeto**

- **Docker-compose**

**1. Rede e Volumes**  
Rede: food_network  
Volumes: master_data, replica1_data, replica_data  

**2. Master**  
Iniciada com os scripts de criação da base de dados e inserção dos dados iniciais.  
Executa scripts na ordem:  
           - Cria utilizador para MaxScale (maxscale_user.sh)  
           - Cria base de dados e tabelas (schema.sql)/init  
           - Insere dados iniciais (seed.sql)  
           - Cria triggers de audit (audit.sql)  
Após a inicialização, a base de dados fica acessível na porta 3309.  

**3. Réplicas**   
Iniciadas nas portas 3307 e 3308, na BD-replica 1 e na BD-replica2, respetivamente.  
Cada réplica espera Master estar ligado para se conectar e iniciar o processo de replicação até ficarem totalmente sincronizadas.  

**4. Inicialização do MaxScale**  
Lê as configurações definidas no ficheiro maxscale.cnf, que cria o monitor.  
Estabelece ligação às três bases de dados: Master, Replica1 e Replica2.  

**5. MariaDB Monitor**  
Verifica o estado do Master e das Réplicas a cada 2 segundos com pings. - health check  
Promove réplica a Master se Master cair - auto-failover  
Reconecta servidores que voltam online - auto-rejoin  
Router: ReadWriteSplit - read-only enforcement  
                - SELECTs são encaminhados para as réplicas.  
                - INSERTs / UPDATEs / DELETEs são enviados para o Master.  
Interface - porta 8989  
Credenciais: admin / mariadb  
Permite monitorizar o estado do Master e das Réplicas.  


- **Serviços Ativos**

localhost:3000 – Express API  
localhost:3309 – MariaDB Master  
localhost:3307 – MariaDB Replica 1  
localhost:3308 – MariaDB Replica 2  
localhost:4006 – MaxScale (router)  
localhost:8989 – MaxScale Dashboard  


- **Imagem food-api**

**/express-server/Dockerfile**

FROM node:20-alpine                   `Faz download da imagem base.`    
WORKDIR /app                          `Define o diretório de trabalho.`    
COPY package*.json                    `Copia o package.json.`  
RUN npm install                       `Instala as dependências.`  
COPY . .                              `Copia o resto do código.`  
EXPOSE 3000                           `Indica a porta usada pelo Express.`  
CMD ["node", "index.js"]              `Inicia o servidor.`  


- **Imagem mariadb-master**

**/mariadb-master/Dockerfile**  
FROM mariadb:11.2                                    `Faz download da imagem base MariaDB.`  
COPY my.cnf /etc/mysql/...                           `Aplica configurações personalizadas do servidor.`  
COPY scripts/ /docker-entrypoint-initdb.d/           `Copia os scripts de inicialização.`  

**Scripts Executados**  
00_maxscale_user.sh                    `Cria o utilizador utilizado pelo MaxScale.`  
01_schema.sh                           `Aponta para o ficheiro principal de schema.`  
01_schema.sql                          `Cria a base de dados e as tabelas.`  
02_seed.sql                            `Insere dados na base de dados.`  
03_audit.sql                           `Configura audit e triggers.`  
04_setup_replication.sql               `Cria o utilizador de replicação e ativa a replicação no Master.`  


- **Imagem mariadb-replicas*

**/replicas/Dockerfile**  
FROM mariadb:11.2                                      `Faz download da imagem base MariaDB.`  
COPY my.cnf /etc/mysql/...                             `Aplica configurações personalizadas do servidor.`  
COPY scripts/ /docker-entrypoint-initdb.d/             `Copia os scripts de inicialização.`  

**RUN chmod +x /docker-entrypoint-initdb.d/*.sh 2>/dev/null || true**  
`Permite que os bash possam ser executados quando o MariaDB estiver pronto.`  

**Scripts Executados**  
01_setup_replication.sh              `Executa fix_replication.sql`   
fix_replication.sql                  `Configura a réplica`  


- **Imagem maxscale**

**/maxscale/Dockerfile**  
FROM mariadb/maxscale:23.08                         `Descarrega a imagem do maxscale`                                 
COPY maxscale.cnf.ini /etc/maxscale.cnf             `Copia a configuração do servidor, monitor e routing`             
  
Assim , o MaxScale liga-se ao mariadb-master, mariadb-replica1, mariadb-replica2. Depois Inicia o MariaDB monitor, ativa o Read/Write Slipt Router e cria o listener da API e o painel de administração.  


- **Base de Dados - Estrutura**

*Tabelas Principais*

**Restaurantes:**  
- id (obrigatório, primary key)
- nome (obrigatório)
- morada (obrigatório)
- telefone
- especialidade
- tempo médio de preparação
- taxa de entrega
- (...)

**Pratos:**  
- restaurante_id (obrigatório) - Relação 1:n com restaurantes
- nome (obrigatório)
- preco (obrigatório)
- descrição (opcionais)
- vegetariano (opcionais)
- disponivel (opcionais)
- (...)

**Clientes:**  
- nome (obrigatório)
- email (obrigatório, único)
- telefone (obrigatório)
- (...)

**Entregas:**  
- cliente_id (obrigatório)
- restaurante_id (obrigatório)
- morada_entrega_id (obrigatório)
- estado (opcional: pendente, a_caminho, entregue, cancelada)
- (...)

**Ingredientes:**   
- nome (obrigatório, único)
- unidade (opcional: g, kg, ml, l, unidade, fatia - padrão: g)
- alergeno (opcional; boolean - padrão: false)
- (...)

**Pedidos:**  
- cliente_id (obrigatório)
- restaurante_id (obrigatório)
- morada_entrega_id (obrigatório)
- metodo_pagamento (obrigatório: cartao, mbway, dinheiro, carteira)
- código_pedido (obrigatório)
- estado (opcionais)
- observações (opcionais)

*Tabelas Secundárias*

**pratos_ingredientes:**  
- prato_id (obrigatório)
- ingrediente_id (obrigatório)
- quantidade (obrigatório)
- (...)

**categorias_pratos:**  
- id (obrigatório)
- nome (obrigatório)
- descricao
- (...)

**moradas_entrega:**  
- cliente_id (obrigatório)
- tipo
- morada (obrigatório)
- codpostal
- cidade

**entregadores:**  
- nome
- email
- telefone
- veículo
- matricula
- GPS
- rating

**pedidos_pratos:**  
- quantidade
- preco_unitario
- subtotal_item.

*Extra*

**audit_log - Os Triggers preenchem as alterações nas tabelas:**  
- restaurantes
- pratos
- clientes
- pedidos
- entregas

- **Postman**

*Restaurante:*  
GET /api/restaurantes -> listar todos os restaurantes  
GET /api/restaurantes/{id} -> listar restaurante pelo seu id  
GET /api/restaurantes/{id}/pratos -> listar pratos de um restaurante  
POST /api/restaurantes -> criar restaurante  
PUT /api/restaurantes/{id} -> atualizar informações do restaurante  
DELETE /api/restaurantes/{id} -> apagar restaurante pelo seu id  

*Pratos:*  
GET /api/pratos -> listar todos os pratos  
GET /api/pratos/{id} -> listar prato pelo seu id  
GET /api/pratos/{id}/ingredientes -> listar ingredientes de um prato  
POST /api/pratos -> criar prato  
POST /api/pratos/{id}/ingredientes -> adicionar ingrediente a um prato  
PUT /api/pratos/{id} -> atualizar informações do prato  
DELETE /api/pratos/{id} -> apagar prato pelo seu id  
DELETE /api/pratos/{id}/ingredientes -> remover ingrediente de um prato  

*Clientes:*  
GET /api/clientes -> listar todos os clientes  
GET /api/clientes/{id} -> listar cliente pelo seu id  
POST /api/clientes -> criar cliente  
PUT /api/clientes/{id} -> atualizar informações do cliente  
DELETE /api/clientes/{id} -> apagar cliente pelo seu id  

*Entregas:*  
GET /api/entregas -> listar todas as entregas  
GET /api/entregas/{id} -> listar determinada entrega  
POST /api/entregas -> criar entrega  
PUT /api/entregas/{id} -> atualizar dados de uma entrega  
DELETE /api/entregas/{id} -> apagar entrega  

*Ingredientes:*  
GET /api/ingredientes -> listar todos os ingredientes  
GET /api/ingredientes/{id} -> listar ingrediente  
POST /api/ingredientes -> criar ingrediente  
PUT /api/ingredientes/{id} -> atualizar informação de determinado prato  
DELETE /api/ingredientes/{id} -> apagar determinado prato  

*Pedidos:*  
GET /api/pedidos -> listar todos os pedidos  
GET /api/pedidos/{id} -> listar determinado pedido  
POST /api/pedidos -> criar pedido  
PUT /api/pedidos/{id} -> atualizar informação de determinado pedido  
DELETE /api/pedidos/{id} -> apagar determinado pedido  

## 3.2 Instalação

_Describe the proper way to install the product._

You can detail code elements and confgurations with code highlight:
```js
const fuz = {a:1, b:3};
let o = new Object();
```  

or

```json
{
    t:1,
    o:[
        a:"testing", 
        b:"alternatives"
    ]
}
```

or

```java

Object o = new Object();

```

you can even do diff

```diff
const x = 100;
- let y = 200;
+ const y = 300;
```

## 3.3 Uso

Após instalação e execução do compose (dev ou prod), a API fica disponível em:

- [localhost:3000/api-docs](http://localhost:3000/api-docs)  
Neste link, estão disponíveis os endpoints, de cada recurso, para realizar. As respostas são devolvidas em formato JSON.

- [localhost:3000/health](http://localhost:3000/health)  
Também disponível, serve para verificar o estado do servidor.

- [localhost:8989](http://localhost:8989)  
Link para aceder ao MaxScale: Monitorização (apenas replicação)

## 3.4 Implementation details

**Requisitos Obrigatórios**

**1. Arquitetura de serviços tipo REST:** 
- cada recurso tem os seus endpoints individuais, com os seus determinados métodos e resposta em json.

**2. Utilização de pelo menos 4 verbos (métodos) do protocolo HTTP - CRUD:** 
- todos os métodos foram utilizados em cada recurso. Exemplo:

No recurso Restaurante:
- GET /api/restaurantes -> listar todos os restaurantes
- GET /api/restaurantes/{id} -> listar restaurante pelo seu id
- GET /api/restaurantes/{id}/pratos -> listar pratos de um restaurante
- POST /api/restaurantes -> criar restaurante
- PUT /api/restaurantes/{id} -> atualizar informações do restaurante
- DELETE /api/restaurantes/{id} -> apagar restaurante pelo seu id

**3. Disponibilizar pelo menos 4 recursos diferentes:** 
- este projeto apresenta Restaurantes, Pratos, Clientes, Ingredientes, Entregas e Pedidos.

**4. Utilização de pelo menos uma relação de cardinalidade 1:n entre dois dos recursos:**
- Exemplos no projeto:

    - restaurantes -> pratos: Um restaurante tem muitos pratos
    - restaurantes -> pedidos: Um restaurante recebe muitos pedidos
    - restaurantes -> entregas: Um restaurante faz muitas entregas
    - pratos -> pedidos: Um prato pode estar em muitos pedidos
    - clientes -> pedidos: Um cliente pode ter muitos pedidos

**5. Disponibilização das representações de estado dos recursos em JSON:**

- Postman ou Swagger

**6. Documentar a API com recurso ao formato OpenAPI 3.0:**
- foi utilizado um ficheiro openapi.yaml.

**7. Disponibilizar uma 'Collection' para o Postman para consulta dos recursos:** 
- foi disponibilizada uma collection postman.

**8. Utilização do MySQL como SGBD:** 
- foi utilizado o MariaDB, com autorização prévia.

**9. Utilização do Node.js como servidor aplicacional para implementação da camada de serviços:** 
- a api foi feita através do Node.js, express server.

**10. Disponibilização de configuração para a aplicação multi-container (pelo menos 2 imagens) MySQL + NodeJS:** 
- foram utilizadas 5 imagens, sendo uma para a API, outra para MariaDB master(principal), outras duas para as réplicas da MariaDB master e uma para o Maxscale (que conecta a base de dados da MariaDB para a API).


**Requisitos Extra**

**1. Filtros através de parâmetros HTTP:**

A API suporta filtros através de query parameters:

- GET /api/restaurantes?especialidade=Italiana - Filtrar por especialidade
- GET /api/pratos?restaurante_id=1 - Filtrar pratos por restaurante
- GET /api/pratos?vegetariano=true - Filtrar pratos vegetarianos
- GET /api/pedidos?estado=pendente - Filtrar pedidos por estado
- GET /api/ingredientes?alergeno=true - Filtrar ingredientes alergénios
   
**2. Utilização de relação de cardinalidade m:n entre dois dos recursos:**

Exemplo:
- **relação pratos <-> ingredientes**, feita através de outra tabela 'pratos_ingredientes', um prato pode ter vários ingredientes, bem como um ingrediente pode estar em vários pratos.
- **pedidos <-> pratos**, feita através de outra tabela 'pedidos_pratos', um pedido pode ter vários pratos e um prato pode estar em vários pedidos.

---
[< Previous](c2.md) | [^ Main](../../../) | [Next >](c4.md)
:--- | :---: | ---: 
